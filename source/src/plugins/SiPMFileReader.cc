/// \file SiPMFileReader.cc
/*
 *
 * SiPMFileReader.cc source template automatically generated by a class generator
 * Creation date : lun. mars 7 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Tom Coates
 * @copyright CNRS , IPNL
 */


// -- std headers 
#include <sstream>

// -- dqm4hep headers
#include <dqm4hep/Event.h>
#include <dqm4hep/EventReader.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/GenericEvent.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/XmlHelper.h>

namespace dqm4hep {

  namespace core {

    /**
     *  @brief  SiPMFileReader class
     *          Read a DREAM SiPM txt datafile and read GenericEvent events from it
     */
    class SiPMFileReader : public EventReader {
    public:
      SiPMFileReader() = default; // The compiler wants headerStream, dataStream and eventContainer initialised in the member intialisation list
      ~SiPMFileReader() override;
      SiPMFileReader(const SiPMFileReader&) = delete;
      SiPMFileReader& operator=(const SiPMFileReader&) = delete;

      core::StatusCode open(const std::string &fname) override;
      core::StatusCode skipNEvents(int nEvents) override;
      core::StatusCode runInfo(core::Run &run) override;
      core::StatusCode readNextEvent() override;
      core::StatusCode close() override;
      
    protected:
      std::istringstream headerStream;
      std::istringstream dataStream;
      std::vector<float> eventContainer;
      TiXmlDocument header;

    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    SiPMFileReader::~SiPMFileReader() {
      //
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::open(const std::string &fname) {

      std::FILE *p_dataFile = std::fopen(fname.c_str(), "rb");
      bool isFileOpenable = p_dataFile;

      if(!isFileOpenable) {
	dqm_error("The file at {0} could not be opened.", fname);
	return STATUS_CODE_FAILURE;
      }

      // Need to open the file, read in the header, then read it line by line, instead of dumping the string as a whole

      std::string rawData;
      std::fseek(p_dataFile, 0, SEEK_END);
      rawData.resize(std::ftell(p_dataFile));
      std::rewind(p_dataFile);
      std::fread(&rawData[0], 1, rawData.size(), p_dataFile);
      std::fclose(p_dataFile);

      std::string headerTagOpen  = "<ACQUISITION_INFO>";
      std::string headerTagClose = "</ACQUISITION_INFO>";
      std::string dataTagStart   = "</START_NOTE>";

      int headerStartPos = rawData.find(headerTagOpen);
      int headerEndPos   = rawData.find(headerTagOpen) + headerTagOpen.size() - headerStartPos;
      int dataStartPos   = rawData.find(dataTagStart)  + dataTagStart.size();

      dataStream.str(rawData.substr(dataStartPos));

      std::string headerString = rawData.substr(headerStartPos, headerEndPos);

      header.Parse(headerString.c_str());

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::skipNEvents(int nEvents) {

      for (int e=0; e<nEvents; e++) {
	std::string currentEventString;
	std::getline(dataStream, currentEventString);
	currentEventString.clear();
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::runInfo(core::Run &run) {

      // this produces a warning, since the run variable isn't used

      // We also need to parse headerStream as an XML here

      /*
      run.setRunNumber();
      run.setDetectorName();
      run.setStartTime();
      */

      // other run info:
      //   temperature
      //   datetime
      //   temperature2
      //   bias
      //   detector board
      //   detector model
      //   detector SN
      //   detector VOP
      //   acquisition board sn
      //   acquisition board RC
      //   board count
      //   board 1 id
      //   board 2 id
      // config info:
      //   trigger mode
      //   trigger level
      //   data delay 1
      //   trigger delay 1
      //   data delay 2
      //   trigger delay 2
      //   trigger hold
      //   polarity
      //   pileup rejector
      //   pileup time
      //   integration time
      //   baseline correction
      //   baseline constant
      //   noise filter
      //   digital gain
      //   correlated board

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::readNextEvent() {
      EventPtr pEvent = GenericEvent::make_shared();
      GenericEvent *pGenericEvent = pEvent->getEvent<GenericEvent>();

      std::string eventDelimiter = ";";
      std::string currentEventString;

      std::getline(dataStream, currentEventString);

      if (currentEventString.size() <= 1) {
	dqm_warning("Event is blank");
	return STATUS_CODE_SUCCESS;
      }
  
      dqm4hep::core::tokenize(currentEventString, eventContainer, eventDelimiter);
  
      if (eventContainer.size() != 66) {
	dqm_error("Event has wrong number of members");
	throw StatusCodeException(STATUS_CODE_FAILURE);
      } 

      // So the setValues() function has to be done on a GenericEvent
      // And setEventNumber() and setTimeStamp() functions have to be done on an Event

      std::vector<float> ev_eventNum = {eventContainer[0]};
      pEvent->setEventNumber(ev_eventNum[0]);

      std::vector<float> ev_time = {eventContainer[1]};
      // This fails because the accepted type is a const TimePoint&
      //pEvent->setTimeStamp(ev_time[0]);  

      eventContainer.erase(eventContainer.begin(),eventContainer.begin()+2);
      pGenericEvent->setValues("Channels", eventContainer);
     
      onEventRead().emit(pEvent);
      return STATUS_CODE_SUCCESS;
    }

    StatusCode SiPMFileReader::close() {

      // Close the file here

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------
    
    DQM_PLUGIN_DECL(SiPMFileReader, "SiPMFileReader");
  }
}
