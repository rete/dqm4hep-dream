/// \file SiPMFileReader.cc
/*
 *
 * SiPMFileReader.cc source template automatically generated by a class generator
 * Creation date : lun. mars 7 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Tom Coates
 * @copyright CNRS , IPNL
 */


// -- std headers 
#include <sstream>

// -- dqm4hep headers
#include <dqm4hep/Event.h>
#include <dqm4hep/EventReader.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/GenericEvent.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/XmlHelper.h>

namespace dqm4hep {

  namespace core {

    /**
     *  @brief  SiPMFileReader class
     *          Read a DREAM SiPM txt datafile and read GenericEvent events from it
     */
    class SiPMFileReader : public EventReader {
    public:
      SiPMFileReader() = default;
      ~SiPMFileReader() override;
      SiPMFileReader(const SiPMFileReader&) = delete;
      SiPMFileReader& operator=(const SiPMFileReader&) = delete;

      core::StatusCode open(const std::string &fname) override;
      core::StatusCode skipNEvents(int nEvents) override;
      core::StatusCode runInfo(core::Run &run) override;
      core::StatusCode readNextEvent() override;
      core::StatusCode close() override;
      
    protected:
      std::fstream inputFile;
      std::istringstream headerStream;
      std::istringstream dataStream;
      TiXmlDocument header;

      std::string sPreamble;
      std::string sHeader; 

    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    SiPMFileReader::~SiPMFileReader() {
      //
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::open(const std::string &fname) {
     
      inputFile.open(fname, std::fstream::in);

      if (!inputFile.is_open()) {
	dqm_error("Failed to open the file at {0}", fname);
	return STATUS_CODE_FAILURE;
      }

      std::string currentLine;

      for(int i = 0; i < 7; i++) {
	std::getline(inputFile, currentLine);
	sPreamble += currentLine + "\n";
      }
      for(int i = 0; i < 300; i++) {
	std::getline(inputFile, currentLine);
	sHeader += currentLine + "\n";
      }
  
      header.Parse(sHeader.c_str());

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::skipNEvents(int nEvents) {

      for (int e=0; e<nEvents; e++) {
	std::string currentEventString;
	std::getline(inputFile, currentEventString);
	currentEventString.clear();
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::runInfo(core::Run &run) {

      TiXmlElement *xmlElement = header.RootElement();
      dqm_debug("Root element is: {0}", xmlElement->ValueStr());

      TiXmlElement *xmlRunInfo = xmlElement->FirstChildElement();
      dqm_debug(xmlRunInfo->ValueStr());
      TiXmlNode *runChild = 0;
      while (runChild = xmlRunInfo->IterateChildren(runChild)) {
	std::string property = runChild->ValueStr();
	std::string propertyContents = runChild->ToElement()->GetText();
	if (property == "RUN_ID") {
	  run.setRunNumber(std::stoi(propertyContents));
	  continue;
	}
	// This is a placeholder for some simple function which can convert a string data intoa TimePoint
	/*i f (property == "DATETIME") {
	  continue;
	  } */
	run.setParameter(property, propertyContents);
	dqm_debug(" {0}: {1}", property, propertyContents);
      }

      TiXmlElement *xmlConfigInfo = xmlRunInfo->NextSiblingElement();
      dqm_debug(xmlConfigInfo->ValueStr());
      TiXmlNode *configChild = 0;
      while (configChild = xmlConfigInfo->IterateChildren(configChild)) {
	std::string property = configChild->ValueStr();
	std::string propertyContents = configChild->ToElement()->GetText();
	run.setParameter(property, propertyContents);
	dqm_debug(" {0}: {1}", configChild->ValueStr(), configChild->ToElement()->GetText());
      }

      TiXmlElement *xmlBiasInfo = xmlConfigInfo->NextSiblingElement();
      dqm_debug(xmlBiasInfo->ValueStr());
      TiXmlNode *biasChild = 0;
      while (biasChild = xmlBiasInfo->IterateChildren(biasChild)) {
	std::string property = biasChild->ValueStr();
	std::string propertyContents = biasChild->ToElement()->GetText();
	run.setParameter(property, propertyContents);
	dqm_debug(" {0}: {1}", biasChild->ValueStr(), biasChild->ToElement()->GetText());
      }

      TiXmlElement *xmlGainOffsetInfo = xmlBiasInfo->NextSiblingElement();
      dqm_debug(xmlGainOffsetInfo->ValueStr());
      TiXmlNode *gainChild = 0;
      while (gainChild = xmlGainOffsetInfo->IterateChildren(gainChild)) {
	std::string property = gainChild->ValueStr();
	std::string propertyContents = gainChild->ToElement()->GetText();
	run.setParameter(property, propertyContents);
	dqm_debug(" {0}: {1}", gainChild->ValueStr(), gainChild->ToElement()->GetText());
      }

      TiXmlElement *xmlThreshold = xmlGainOffsetInfo->NextSiblingElement();
      dqm_debug(xmlThreshold->ValueStr());
      TiXmlNode *thresholdChild = 0;
      while (thresholdChild = xmlThreshold->IterateChildren(thresholdChild)) {
	std::string property = thresholdChild->ValueStr();
	std::string propertyContents = thresholdChild->ToElement()->GetText();
	run.setParameter(property, propertyContents);
	dqm_debug(" {0}: {1}", thresholdChild->ValueStr(), thresholdChild->ToElement()->GetText());
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode SiPMFileReader::readNextEvent() {
      EventPtr pEvent = GenericEvent::make_shared();
      GenericEvent *pGenericEvent = pEvent->getEvent<GenericEvent>();

      std::string eventDelimiter = ";";
      std::string currentEventString;
      std::vector<float> eventContainer;

      while (eventContainer.size() == 0) {
	if (inputFile.eof() == true) {
	  dqm_info("Reached end of file");
	  return STATUS_CODE_OUT_OF_RANGE;
	}

	std::getline(inputFile, currentEventString);
	dqm4hep::core::tokenize(currentEventString, eventContainer, eventDelimiter);
      }

      if (eventContainer.size() != 66) {
	dqm_error("Event has wrong number of members");
	return STATUS_CODE_FAILURE;
      } 

      std::vector<int> ev_eventNum = {eventContainer[0]};
      pEvent->setEventNumber(ev_eventNum[0]);

      std::vector<int> ev_time = {eventContainer[1]};
      pEvent->setTimeStamp(core::time::asPoint(ev_time[0]));

      eventContainer.erase(eventContainer.begin(),eventContainer.begin()+2);
      pGenericEvent->setValues("Channels", eventContainer);

      onEventRead().emit(pEvent);
      return STATUS_CODE_SUCCESS;
    }

    StatusCode SiPMFileReader::close() {
      inputFile.close();
      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------
    
    DQM_PLUGIN_DECL(SiPMFileReader, "SiPMFileReader");
  }
}
